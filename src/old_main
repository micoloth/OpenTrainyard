use bevy::{log, transform};
use bevy::log::{Level, LogSettings};
use bevy::prelude::*;
use bevy::prelude::Vec3;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::process::Child;
// use bevy::ecs::schedule::StateData;
use bevy::prelude::Vec2;
use bevy::core::FixedTimestep;  // 0.9: Thi is in Time, not in core
use bevy::math::Vec3Swizzles;
use bevy::prelude::Component;
use std::fmt::{self, Display, Formatter};
use std::ops::{Add, Sub};

mod simulator;
use simulator::*;

// mod map_printer;
// use map_printer::*;
// use map_printer::add_color_minitiles;

// REMEMBER: with >> inster() <<, YOU CAN ALWAYS INSERT A COMPONENT, EVEN IF IT IS NOT PRESENT IN THE ENTITY !!! IT's PURPOSEFULLY VERY SIMPLE !!!


mod tests_;
use tests_::test;




/////////////////////////////////////////////////////////////////////////////////////
// COMPONENTS
/////////////////////////////////////////////////////////////////////////////////////

use bevy::prelude::*;
use bevy::ecs::system::EntityCommands;

// use staticvec::{staticvec, StaticVec};

#[derive(Debug, Copy, Clone, Serialize, Deserialize)]
pub struct Bounds2 {
    pub position: Vec2,
    pub size: Vec2,
}
impl Bounds2 {
    #[inline]
    #[must_use]
    pub fn in_bounds(&self, coords: Vec2) -> bool {
        coords.x >= self.position.x
            && coords.y >= self.position.y
            && coords.x <= self.position.x + self.size.x
            && coords.y <= self.position.y + self.size.y
    }
}



// Assets for the trains. Must be used as a resource.
#[derive(Debug, Clone, Default)]
pub struct TrainAssets {
    train_blue: Handle<Image>,
    train_red: Handle<Image>,
    train_yellow: Handle<Image>,
    train_orange: Handle<Image>,
    train_green: Handle<Image>,
    train_purple: Handle<Image>,
    train_brown: Handle<Image>,
}
fn get_train_assets(asset_server: &Res<AssetServer>) -> TrainAssets {
    return TrainAssets {
        train_blue: asset_server.load("samples/s_arrow_elem_rigth.png"),  // "samples/train_blue.png"),
        train_red: asset_server.load("samples/s_arrow_elem_rigth.png"),  // "samples/train_red.png"),
        train_yellow: asset_server.load("samples/s_arrow_elem_rigth.png"),  // "samples/train_yellow.png"),
        train_orange: asset_server.load("samples/s_arrow_elem_rigth.png"),  // "samples/train_orange.png"),
        train_green: asset_server.load("samples/s_arrow_elem_rigth.png"),  // "samples/train_green.png"),
        train_purple: asset_server.load("samples/s_arrow_elem_rigth.png"),  // "samples/train_purple.png"),
        train_brown: asset_server.load("samples/s_arrow_elem_rigth.png"),  // "samples/train_brown.png"),
    }
}
fn get_train_image(train_assets: &TrainAssets, color: Colorz) -> Handle<Image> {
    match color {
        Colorz::RED_ => train_assets.train_red.clone(),
        Colorz::BLUE_ => train_assets.train_blue.clone(),
        Colorz::YELLOW_ => train_assets.train_yellow.clone(),
        Colorz::ORANGE_ => train_assets.train_orange.clone(),
        Colorz::GREEN_ => train_assets.train_green.clone(),
        Colorz::PURPLE_ => train_assets.train_purple.clone(),
        Colorz::BROWN_ => train_assets.train_brown.clone(),
    }
}



// Assets for the board. Must be used as a resource.
//
// Use the loader for partial setup
#[derive(Debug, Clone)]
pub struct BoardAssetsMap {
    pub assets: HashMap<String, Handle<Image>>,
}

pub fn get_assets_in_a_hashmap(asset_server: &Res<AssetServer>)-> BoardAssetsMap {
    let prefixes = vec!["s", "e"];
    let dimensions = vec![1, 9, 4];
    let colors = vec!["blue", "brown", "green", "orange", "purple", "red", "yellow"];
    let mut assets: HashMap<String, Handle<Image>> = HashMap::new();
    for prefix in prefixes.iter() {
        for dimension in dimensions.iter() {
            for color in colors.iter() {
                let key = format!("{}_elem_{}_{}.png", prefix, dimension, color);
                let value = format!("samples/{}_elem_{}_{}.png", prefix, dimension, color);
                // Check if file in "value" exists:
                // Concatenate "assets/" with "value":
                let asset_path = format!("assets/{}", value);
                if std::path::Path::new(&asset_path).exists() {
                    assets.insert(key, asset_server.load(&value));
                }
            }
        }
    }
    assets.insert("br_over_tb.png".to_string(), asset_server.load("samples/br_over_tb.png"));
    assets.insert("br.png".to_string(), asset_server.load("samples/br.png"));
    assets.insert("e_base.png".to_string(), asset_server.load("samples/e_base.png"));
    assets.insert("e_funnel_elem_rigth.png".to_string(), asset_server.load("samples/e_funnel_elem_rigth.png"));
    assets.insert("empty.png".to_string(), asset_server.load("samples/empty.png"));
    assets.insert("lr_over_tb.png".to_string(), asset_server.load("samples/lr_over_tb.png"));
    assets.insert("p_blue.png".to_string(), asset_server.load("samples/p_blue.png"));
    assets.insert("p_green.png".to_string(), asset_server.load("samples/p_green.png"));
    assets.insert("p_orange.png".to_string(), asset_server.load("samples/p_orange.png"));
    assets.insert("p_outer_cur_br.png".to_string(), asset_server.load("samples/p_outer_cur_br.png"));
    assets.insert("p_outer_str_lr.png".to_string(), asset_server.load("samples/p_outer_str_lr.png"));
    assets.insert("p_purple.png".to_string(), asset_server.load("samples/p_purple.png"));
    assets.insert("p_red.png".to_string(), asset_server.load("samples/p_red.png"));
    assets.insert("p_yellow.png".to_string(), asset_server.load("samples/p_yellow.png"));
    assets.insert("rock.png".to_string(), asset_server.load("samples/rock.png"));
    assets.insert("s_arrow_elem_rigth.png".to_string(), asset_server.load("samples/s_arrow_elem_rigth.png"));
    assets.insert("s_base.png".to_string(), asset_server.load("samples/s_base.png"));
    assets.insert("scissor_u.png".to_string(), asset_server.load("samples/scissor_u.png"));
    assets.insert("tb_over_br.png".to_string(), asset_server.load("samples/tb_over_br.png"));
    assets.insert("tb.png".to_string(), asset_server.load("samples/tb.png"));
    assets.insert("tr_over_tl.png".to_string(), asset_server.load("samples/tr_over_tl.png"));
    assets.insert("track_funny_tr_bl.png".to_string(), asset_server.load("samples/track_funny_tr_bl.png"));

    let res =  BoardAssetsMap{assets: assets};
    // println!("assets keys are: {:?}", res.assets.keys());
    return res;
}

// let mut v = StaticVec::<usize, 4>::new();

// Julia code:
// function add_color_minitiles!(base, elems, is_start)
//     # Add the colors:
//     # Check if length(t.elems) fits in 1, 4  or 9:
//     prefix = if is_start "s" else "e" end
//     (N, poss) = if length(elems) == 1 (1, poss_minitile_1)
//         elseif length(elems) <= 4 (4, poss_minitile_4)
//         elseif length(elems) <= 9 (9, poss_minitile_9)
//         else raise("Too many elements in StartTile")
//     end
//     for (i, pos_y) in enumerate(poss)
//         for (j, pos_x) in enumerate(poss)
//             n_to_get = (i-1)*length(poss) + j
//             if n_to_get <= length(elems)
//                 minitile =  samples["$(prefix)_elem_$(N)_$(string(elems[n_to_get])[1:end-1]).png"]
//                 base[pos_y:(pos_y+size(minitile)[1]-1), pos_x:(pos_x+size(minitile)[2]-1)] = minitile
//             else
//                 break
//             end
//         end
//     end
// end
// Turn Julia code into Rust code: 
// Julia to Rust:




// Julia code:
// function add_arrow_minitile!(base, dir)
//     arrow = samples["s_arrow_elem_rigth.png"]
//     # Add the arrow:
//     if dir == r_
//         base[13:(46-13+1), (46-6+1):end] = arrow
//     elseif dir == l_
//         base[13:(46-13+1), 1:6] = flipmatrix_horizontal(arrow)
//     elseif dir == t_
//         base[1:6, 13:(46-13+1)] = rotate_tile(arrow, 1)
//     elseif dir == b_
//         base[(46-6+1):end, 13:(46-13+1)] = rotate_tile(arrow, -1)
//     end
// end
// Turn Julia code into Rust code: 
// Julia to Rust:



// extern crate partial_application;


// # make_start(StartTile(b_, [red_, blue_, green_]))
// # make_end(EndTile(false, true, true, false, [red_]))
// # parseTile(printTile(EndTile(false, true, true, false, [red_])))
// # parseTile(printTile(StartTile(b_, [red_, blue_, green_])))





// track_functions_dict = Dict(

// )

//Julia to Rust:



pub fn make_train(train: Train, commands: &mut Commands, train_assets: &TrainAssets, board_dimensions: &BoardDimensions, tick_rateo: f32) -> Entity {
    
    let transform = get_train_transform(train, board_dimensions, tick_rateo);
    let child = commands.spawn_bundle(TrainBundle {
        train: train,
        texture: get_train_image(train_assets, train.c),
        transform: transform,
        // sprite: Sprite { custom_size: Some(Vec2::splat(board_dimensions.tile_size)), color: Color::WHITE, ..Default::default()},
        global_transform: Default::default(), visibility: Default::default(), sprite: Default::default(),
    });
    return child.id();
}








#[derive(Bundle)]
pub struct TrainBundle{
    pub train: Train,

    // Flattened SpriteBundle #[bundle] : SO NICE!!
    pub sprite: Sprite,
    pub transform: Transform,
    pub global_transform: GlobalTransform,
    pub texture: Handle<Image>,
    pub visibility: Visibility, // User indication of whether an entity is visible
}






/////////////////////////////////////////////////////////////////////////////////////
// SYSTEMS HELPER FUNCTIONS
/////////////////////////////////////////////////////////////////////////////////////

// Translates a mouse position to board coordinates












fn get_train_transform(t:Train, board: &BoardDimensions, tick_rateo: f32) -> Transform {
    let mut transform = Transform::from_translation(Vec3::new(0.0, 0.0, 2.0));
    let in_side: Side = t.pos.side;
    let out_side: Side = t.pos.towards_side.unwrap();

    let angle = tick_rateo * 0.5 * std::f32::consts::PI;

    let (x, y, train_angle) =  match (in_side, out_side) {
        // For STRAIGHT tracks (in/out is right/left or top/bottom), the train should go from left to rigth or right to left. Use tick_rateo to get the fraction of the way.
        // ASSUME THAT the tile has side 1, and the origin is in the TOP LEFT corner ( x=0 is leftmost, Y=0 is topmost)
        (Side::L_, Side::R_) => {(tick_rateo, 0.5, 0.)},
        (Side::R_, Side::L_) => {(1. - tick_rateo, 0.5, - std::f32::consts::PI)},
        (Side::T_, Side::B_) => {(0.5, 1. - tick_rateo, - std::f32::consts::PI / 2.)},
        (Side::B_, Side::T_) => {(0.5, tick_rateo, std::f32::consts::PI / 2.)},
        // For CURVED tracks, the train should do a CURVED arc from one side of the tile to the other, PIVOTING AROUND THE CONER, that is a CONCAVE arc towards the center of the tile.
        (Side::R_, Side::T_) => {( 1.- 0.5*angle.sin(), 1. - 0.5 * angle.cos(), - angle + std::f32::consts::PI)},
        (Side::T_, Side::L_) => {(0.5* angle.cos(), 1. - 0.5 * angle.sin(), -angle - std::f32::consts::PI /2.)},
        (Side::L_, Side::B_) => {( 0.5*angle.sin(), 0.5 * angle.cos(), - angle)},
        (Side::B_, Side::R_) => {(1. - 0.5* angle.cos(), 0.5*angle.sin(), - angle + std::f32::consts::PI /2.)},
        (Side::T_, Side::R_) => {(1. - 0.5* angle.cos(), 1.- 0.5 * angle.sin(), angle - std::f32::consts::PI /2.)},
        (Side::R_, Side::B_) => {(1. - 0.5*angle.sin(), 0.5 * angle.cos(), angle + std::f32::consts::PI)},
        (Side::B_, Side::L_) => {(0.5* angle.cos(), 0.5 * angle.sin(), angle + std::f32::consts::PI /2.)},
        (Side::L_, Side::T_) => {( 0.5*angle.sin(), 1. - 0.5 * angle.cos(), angle)},
        _ => {panic!("WTF")}
        };
        transform.translation.x = (x + t.pos.px as f32) * board.tile_size;
        transform.translation.y = (y + (6 - t.pos.py)as f32) * board.tile_size;
        transform.rotation = Quat::from_rotation_z( train_angle);
        
        transform.scale = Vec3::splat(2.5);
        
        return transform;
}




/////////////////////////////////////////////////////////////////////////////////////
// SYSTEMS
/////////////////////////////////////////////////////////////////////////////////////







fn move_trains(
        mut trains_q: Query<(&mut Train, &mut Transform)>, 
        // windows: Res<Windows>,
        board_q: Query<(&BoardDimensions), With<Board>>,
        mut tick_status: ResMut<TicksInATick>,
        mut logic_tick_event: EventWriter<LogicTickEvent>) {
            
            
    if tick_status.locked_waiting_for_tick_event || !tick_status.is_in_game {return;}
    for (board_dimensions) in board_q.iter() {    // Really, there's just 1 board
        for (train, mut transform) in trains_q.iter_mut() {
            *transform = get_train_transform(*train, board_dimensions, (tick_status.current_tick as f32) / (tick_status.ticks as f32));
        }
    }
    tick_status.current_tick += 1;
    if tick_status.current_tick >= tick_status.ticks {
        tick_status.current_tick = 0;
        tick_status.locked_waiting_for_tick_event = true;
        logic_tick_event.send(LogicTickEvent::TickEnd);
    } else if tick_status.current_tick == ((tick_status.ticks as f32 / 2.) as u32) {
        logic_tick_event.send(LogicTickEvent::TickMiddle);
        tick_status.locked_waiting_for_tick_event = true;
    }
}


// children: Query<(Entity, &Parent), With<Uncover>>,
// parents: Query<(&Coordinates, Option<&Bomb>, Option<&BombNeighbor>)>,
// mut board_completed_event_wr: EventWriter<BoardCompletedEvent>,
// mut bomb_explosion_event_wr: EventWriter<BombExplosionEvent>,
// ) {
// // We iterate through tile covers to uncover
// for (entity, parent) in children.iter() {
//     // we destroy the entity
//     commands.entity(entity).despawn_recursive();

fn logic_tick_event(
        mut commands: Commands,
        train_assets: Res<TrainAssets>,
        mut board_q: Query<(Entity, &BoardDimensions, &mut BoardEntities, &mut BoardTileMap), With<Board>>,
        trains_q: Query<(Entity, &Train)>,
        mut tick_status: ResMut<TicksInATick>,
        mut evt: EventReader<LogicTickEvent>,
        mut spawn_event: EventWriter<TileSpawnEvent>
    ) {
    for trigger_event in evt.iter() {
        for (board_id, board_dimensions, mut board_entities, mut board_tilemap) in board_q.iter_mut() {
            // if board is not None:
            
            // Despawn all trains sprites and save the train in current_trains: 
            let mut current_trains: Vec<Train> = Vec::new();
            for (train_entity, train) in trains_q.iter() {
                let mut board_entity = commands.entity(board_id);  // Get entity by id:
                current_trains.push(*train);
                board_entity.remove_children(&[train_entity]);
                commands.entity(train_entity).despawn_recursive();
            }

            let mut crashed;
            let mut  completed;
            let mut new_tilemap: Vec<Vec<Tile>>;
            let mut new_trains: Vec<Train>;
            (new_tilemap, new_trains) = (board_tilemap.map.clone(), current_trains);

            if *trigger_event == LogicTickEvent::TickEnd {
                (new_tilemap, new_trains) = go_to_towards_side(new_trains, new_tilemap);
                (new_tilemap, new_trains) = add_beginnings(new_trains, new_tilemap);
                (new_tilemap, new_trains) = flip_exchanges(new_trains, new_tilemap);
                (new_tilemap, new_trains) = check_merges(new_trains, new_tilemap);
                (new_tilemap, new_trains) = check_border_collisions(new_trains, new_tilemap);
                (crashed, completed, new_tilemap, new_trains) = check_arrived_or_crashed(new_trains, new_tilemap);
                (new_tilemap, new_trains) = set_towards_side(new_trains, new_tilemap);
                
                prettyPrintMap(&new_tilemap);
                // Send an event to spawn all changed tiles:
                for (y, line) in new_tilemap.iter().enumerate() {
                    for (x, tile) in line.iter().enumerate() {
                        if tile != &board_tilemap.map[y][x] {
                            spawn_event.send(TileSpawnEvent { x, y, new_tile: *tile});
                            board_tilemap.map[y][x] = *tile;
                        }
                    }
                }
            }
            else if *trigger_event == LogicTickEvent::TickMiddle {
                (new_tilemap, new_trains) = check_center_colliding(new_trains, new_tilemap);
                (new_tilemap, new_trains) = do_center_coloring_things(new_trains, new_tilemap);
                println!("");
                println!("");
                println!("");
                println!("");
                println!("");
            }
            else{
                panic!("Unknown LogicTickEvent: for now we dont use {:?}", trigger_event);
            }
            
            // spawnn all trains:
            for train in new_trains {
                let child_id = make_train(train, &mut commands, &train_assets, &board_dimensions, tick_status.current_tick as f32 / tick_status.ticks as f32);
                let mut board_entity = commands.entity(board_id);  // Get entity by id:
                board_entity.push_children(&[child_id]);// add the child to the parent
            };

            break; // Never ever 2 logic ticks should happen sincronously anyway
        }
        break; // Never ever 2 logic ticks should happen sincronously anyway
    }
    tick_status.locked_waiting_for_tick_event = false;
}




#[allow(clippy::type_complexity)]
fn input_handler(
    button_colors: Res<ButtonColors>,
    mut interaction_query: Query<(&Interaction, &ButtonAction, &mut UiColor),(Changed<Interaction>, With<Button>)>,
    mut state: ResMut<State<AppState>>,
) {
    for (interaction, action, mut color) in interaction_query.iter_mut() {
        match *interaction {
            Interaction::Clicked => {
                *color = button_colors.pressed.into();
                match action {
                    ButtonAction::Clear => {
                        log::debug!("clearing detected");
                        if state.current() == &AppState::InGame {
                            log::info!("clearing game");
                            state.set(AppState::Out).unwrap();
                        }
                    }
                    ButtonAction::Generate => {
                        log::debug!("loading detected");
                        if state.current() == &AppState::Out {
                            log::info!("loading game");
                            state.set(AppState::InGame).unwrap();
                        }
                    }
                }
            }
            Interaction::Hovered => {
                *color = button_colors.hovered.into();
            }
            Interaction::None => {
                *color = button_colors.normal.into();
            }
        }
    }
}

// fn setup_ui(mut commands: Commands, asset_server: Res<AssetServer>, asset_shapes: Res<BoardAssetsMap>) {
fn setup_ui(mut commands: &mut Commands, asset_server: &AssetServer, asset_shapes: &BoardAssetsMap) {
    let button_materials = ButtonColors {
        normal: Color::GRAY,
        hovered: Color::DARK_GRAY,
        pressed: Color::BLACK,
    };
    commands
        .spawn_bundle(NodeBundle {
            style: Style {
                size: Size::new(Val::Percent(100.), Val::Px(50.)),
                align_items: AlignItems::Center,
                justify_content: JustifyContent::Center,

                ..Default::default()
            },
            color: Color::WHITE.into(),
            ..Default::default()
        })
        .insert(Name::new("UI"))
        .with_children(|parent| {
            let font = asset_server.load("fonts/pixeled.ttf");
            setup_single_menu(
                parent,
                "CLEAR",
                button_materials.normal.into(),
                font.clone(),
                ButtonAction::Clear,
            );
            // setup_scrollbar(
            //     parent,
            //     "GENERATE",
            //     button_materials.normal.into(),
            //     font,
            //     ButtonAction::Generate,
            //     &asset_shapes.assets
            // );
        });
    commands.insert_resource(button_materials);
}

fn setup_single_menu(
    parent: &mut ChildBuilder,
    text: &str,
    color: UiColor,
    font: Handle<Font>,
    action: ButtonAction,
) {
    parent
        .spawn_bundle(ButtonBundle {
            style: Style {
                size: Size::new(Val::Percent(95.), Val::Auto),
                margin: Rect::all(Val::Px(10.)),
                // horizontally center child text
                justify_content: JustifyContent::Center,
                // vertically center child text
                align_items: AlignItems::Center,
                ..Default::default()
            },
            color,
            ..Default::default()
        })
        .insert(action)
        .insert(Name::new(text.to_string()))
        .with_children(|builder| {
            builder.spawn_bundle(TextBundle {
                text: Text {
                    sections: vec![TextSection {
                        value: text.to_string(),
                        style: TextStyle {
                            font,
                            font_size: 30.,
                            color: Color::WHITE,
                        },
                    }],
                    alignment: TextAlignment {
                        vertical: VerticalAlign::Center,
                        horizontal: HorizontalAlign::Center,
                    },
                },
                ..Default::default()
            });
        });
}



use bevy::ui::widget::ImageMode;
use bevy::ui::FocusPolicy;
#[derive(Debug, Component, Clone, PartialEq, Copy, Default)] pub struct ScrollBarLimits { max: f32, min: f32, current: f32, step: f32,}
#[derive(Debug, Component, Clone, PartialEq, Copy, Default)] pub struct ScrollBarPosition { max_x: f32, min_x: f32, current_x: f32, step_x: f32,}
#[derive(Debug, Component, Clone, PartialEq, Copy, Default)] pub struct ScrollBarStatus { dragging: bool }

#[derive(Bundle, Clone, Debug, Default)]
pub struct ScrollBarHandleBundle {
    pub scrollBarLimits: ScrollBarLimits,
    pub scrollBarPosition: ScrollBarPosition,
    pub scrollBarStatus: ScrollBarStatus,

    pub sprite: Sprite,

    // Flattened components of ImageBundle AND ButtonBundle - Nice!   (kinda .....)
    pub style: Style,  // Describes the style including flexbox settings
    pub image_mode: ImageMode,  // Configures how the image should scale
    pub calculated_size: CalculatedSize,  // The calculated size based on the given image
    pub color: UiColor,  // The color of the node
    pub image: UiImage,  // The image of the node
    pub transform: Transform,  // The transform of the node
    pub global_transform: GlobalTransform,  // The global transform of the node
    pub visibility: Visibility,  // Describes the visibility properties of the node
    pub button: Button,  // Marker component that signals this node is a button
    pub interaction: Interaction,  // Describes whether and how the button has been interacted with by the input
    pub focus_policy: FocusPolicy,  // Whether this node should block interaction with lower nodes
}

pub fn getScrollBarHandleBundle(img: Handle<Image>, color: UiColor, limits: ScrollBarLimits) -> ScrollBarHandleBundle {
    let mut sbh = ScrollBarHandleBundle{
        image: UiImage(img),
        transform: Transform::from_translation(Vec3::new(0., 0., 3.)).with_scale(Vec3::splat(5.)),
        global_transform: Default::default(), visibility: Default::default(),
        ..Default::default()
    };

    return sbh;
}



fn setup_scrollbar(
    parent: &mut ChildBuilder,
    text: &str,
    color: UiColor,
    font: Handle<Font>,
    action: ButtonAction,
    assets: &HashMap<String, Handle<Image>>, 
) {
    let arrow = assets.get("s_arrow_elem_rigth.png").unwrap();
    parent
        .spawn_bundle(
            NodeBundle {
                style: Style {
                    size: Size::new(Val::Percent(95.), Val::Auto),
                    margin: Rect::all(Val::Px(10.)),
                    // horizontally center child text
                    justify_content: JustifyContent::Center,
                    // vertically center child text
                    align_items: AlignItems::Center,
                    ..Default::default()
                },
                color,
                ..Default::default()
        })
        .with_children(|builder| {
            builder.spawn_bundle(
                getScrollBarHandleBundle((*arrow).clone(), color, ScrollBarLimits { max: 100., min: 0., current: 0., step: 1.})
            );
        })
        .insert(Name::new(text.to_string()));
}

#[allow(clippy::type_complexity)]
fn scrollbar_input_handler(
    button_colors: Res<ButtonColors>,
    mut interaction_query: Query<(&Interaction, &mut UiColor, &mut ScrollBarPosition, &mut ScrollBarLimits, &mut ScrollBarStatus),(Changed<Interaction>)>,
    mut state: ResMut<State<AppState>>,
) {
    for (interaction, mut color, mut sbpos, mut sblimits, mut sbstatus) in interaction_query.iter_mut() {
        match *interaction {
            Interaction::Clicked => {
                // Set the image transparency to 0.5:
                if let Color::Rgba { red, green, blue, alpha } = color.0.as_rgba(){  // Surprise surprise!
                    *color = Color::rgba(red, green, blue, 0.5).into();
                }
                sbstatus.dragging = true;
            }
            Interaction::Hovered => {
                if let Color::Rgba { red, green, blue, alpha } = color.0.as_rgba(){  // Surprise surprise!
                    *color = Color::rgba(red, green, blue, 0.1).into();
                }
            }
            Interaction::None => {
                *color = button_colors.normal.into();
                sbstatus.dragging = false;
            }
        }
    }
}



#[allow(clippy::type_complexity)]
fn scrollbar_dragging_handler(
    button_colors: Res<ButtonColors>, 
    windows: Res<Windows>,
    mut interaction_query: Query<(&mut Transform, &mut GlobalTransform, &mut Style, &mut ScrollBarPosition, &mut ScrollBarLimits, &mut ScrollBarStatus)>,
    mut state: ResMut<State<AppState>>,
) {
    for (mut transform, mut gltr, mut style, mut sbpos, mut sblimits, mut sbstatus) in interaction_query.iter_mut() {
        if sbstatus.dragging {
            let window = windows.get_primary().expect("no primary window");
            let window_size = Vec2::new(window.width(), window.height());
            if let Some(pos) = window.cursor_position() {
                println!("THANKSSS, {:?}", pos);
                let position = pos - window_size / 2.;
                let pos_x = position.x;
                sbpos.current_x = pos_x;

                // print current x position of the image from transform:
                println!("Current x position of the image: {:?}", transform.translation.x);
                // transform.translation.x = pos_x;
                // let mut old_pos:Rect<Val> = style.position;
                // old_pos.left = Val::Px(pos_x as f32);
                // old_pos.right = Val::Px((pos_x as f32) + 20.);
                // style.position = old_pos;
                
                println!("New x position of the image: {:?}", gltr.translation.x);
                println!("New x position of the image: {:?}", style.position);

            }

        }
    }
}






fn setup_static_resources(mut commands: Commands, asset_server: Res<AssetServer>, ) {
    let assets = get_assets_in_a_hashmap(&asset_server);
    setup_ui(&mut commands, &asset_server, &assets);
    commands.insert_resource(get_BoardOptionsDefault());
    commands.insert_resource(get_TicksInATickDefault());
    commands.insert_resource(get_train_assets(&asset_server));
    commands.insert_resource(assets);
}

fn setup_game_state(mut state: ResMut<State<AppState>>){ 
    state.set(AppState::InGame).unwrap();  // Launch game
}
fn setup_camera(mut commands: Commands) {
    commands.spawn_bundle(OrthographicCameraBundle::new_2d());  // 2D orthographic camera
    commands.spawn_bundle(UiCameraBundle::default());  // UI Camera
}

// Defines the amount of time that should elapse between each physics step.
const TIME_STEP: f32 = 1.0 / 60.0;


fn main() {
    
    
    test();


    let mut app = App::new();
    app
    .insert_resource(WindowDescriptor { title: "Mine Sweeper!".to_string(), width: 700., height: 750., ..Default::default() }) // Window setup
    .insert_resource(LogSettings { level: Level::INFO, ..Default::default() }) // Log setup
    .add_plugins(DefaultPlugins) // Bevy default plugins
    .add_startup_system(setup_camera) // Startup system (cameras)
    .add_startup_system(setup_game_state) // Startup system (game state)
    .add_startup_system(setup_static_resources)
    .add_system_set(SystemSet::on_enter(AppState::InGame).with_system(create_board),)
    .add_system_set(SystemSet::on_exit(AppState::InGame).with_system(cleanup_board),)
    .add_system(input_handler) // State handling
    .add_system(scrollbar_input_handler) // State handling
    .add_system(scrollbar_dragging_handler) // State handling
    .add_system(spawn_tile) // State handling
    .add_system(logic_tick_event) // State handling
    .add_event::<TileSpawnEvent>()
    .add_event::<LogicTickEvent>()
    .add_state(AppState::Out)
    .add_system_set(
        SystemSet::new()
        .with_run_criteria(FixedTimestep::step(TIME_STEP as f64))
        .with_system(check_mouse_action)
        .with_system(move_trains)   
    )
    .run(); // Run the app




}



////////////////////////// HELPUL THING: TYPES OF ADD SYSTEMS
// .add_system_set(SystemSet::on_update(AppState::InGame).with_system(...))  
// .add_system_set(SystemSet::on_in_stack_update(AppState::InGame).with_system(...),)  


////////////////////////// HELPFUL THING: ANIMATION
//
// The sprite is animated by changing its translation depending on the time that has passed since
// the last frame.
// fn sprite_movement(time: Res<Time>, mut sprite_position: Query<(&mut Direction, &mut Transform)>) {
//     for (mut logo, mut transform) in &mut sprite_position {
//         match *logo {
//             Direction::Up => transform.translation.y += 150. * time.delta_seconds(),
//             Direction::Down => transform.translation.y -= 150. * time.delta_seconds(),
//         }

//         if transform.translation.y > 200. {
//             *logo = Direction::Down;
//         } else if transform.translation.y < -200. {
//             *logo = Direction::Up;
//         }
//     }
// }

////////////////////////// HELPFUL THING: TEXT
//
// Generates the bomb counter text 2D Bundle for a given value
// fn bomb_count_text_bundle(
//     count: u8,
//     board_assets: &Res<BoardAssets>,
//     size: f32,
// ) -> Text2dBundle {
//     // We retrieve the text and the correct color
//     let color = board_assets.bomb_counter_color(count);
//     // We generate a text bundle
//     Text2dBundle {
//         text: Text {
//             sections: vec![TextSection {
//                 value: count.to_string(),
//                 style: TextStyle {
//                     color,
//                     font: board_assets.bomb_counter_font.clone(),
//                     font_size: size,
//                 },
//             }],
//             alignment: TextAlignment {
//                 vertical: VerticalAlign::Center,
//                 horizontal: HorizontalAlign::Center,
//             },
//         },
//         transform: Transform::from_xyz(0., 0., 1.),
//         ..Default::default()
//     }
// }


////////////////////////// HELPFUL THING: ANOTHER WAY TO READ MOUSE (Clicks Only)
// use bevy::input::{mouse::MouseButtonInput, ElementState};
// pub fn input_handling( windows: Res<Windows>, mut button_evr: EventReader<MouseButtonInput>,) {
// let window = windows.get_primary().unwrap();
// for event in button_evr.iter() {
//     if let ElementState::Pressed = event.state {
//         let position = window.cursor_position();
//         if let Some(pos) = position {
//             match event.button {
//                 MouseButton::Left => {}
//                 MouseButton::Right => {}
//                 _ => (),
//             }
//         }
//     }
// }
// }